package pages

import "github.com/byvko-dev/youtube-app/internal/types"

templ Video(props types.VideoPlayerProps) {
	<head>
		<title>Feedlr - Test</title>
		<meta property="og:title" content={ props.Video.Title }/>
		<meta property="og:type" content="video.episode"/>
		<meta property="og:description" content={ props.Video.Description }/>
		<meta property="og:image" content={ props.Video.Thumbnail }/>
	</head>
	
	<div class="relative flex items-center justify-start w-full h-full">
		<div class="absolute flex items-center justify-center w-full h-full bg-black" id="player-loading">
			<span class="w-12 h-12 loading loading-spinner"></span>
		</div>

		@videoPlayer(props)
		
		if (props.ReportProgress) {
			@buttonBack()
		} else {
			@buttonLogin()
		}
	</div>
}

templ videoPlayer(player types.VideoPlayerProps) {
	<div id="player"></div>
	<iframe src="about:blank" onload={ sponsorBlockInit(player.SkipSegments) } />
	<iframe src="about:blank" onload={ youtubePlayerInit(player.Video.ID, player.Video.Progress, player.ReportProgress) } />
	<script id="" src="https://www.youtube.com/iframe_api" onload="window.onYouTubeIframeAPIReady()"></script>
}

templ buttonLogin() {
	<a class="absolute opacity-50 hover:opacity-100 top-2 right-2 btn btn-primary" href="/login" id="close-button">
		Login
	</a>
}

templ buttonBack() {
	<a class="absolute opacity-50 hover:opacity-100 top-2 right-2 btn btn-primary" href="/app" id="close-button">
		X
	</a>
}

script youtubePlayerInit(video string, progress int, withProgress bool) {
	console.log("youtubePlayerInit", video, progress, withProgress)

	if (withProgress) {
		document.getElementById("close-button")?.addEventListener("click", saveProgress)
		setInterval(saveProgress, 10000)
	}
	
	window.onYouTubeIframeAPIReady = () => {
		setTimeout(() => {
		window.player = new YT.Player("#player", {
			height: '100%',
			width: '100%',
			videoId: video,
			playerVars: {
				'start': progress,
				'rel': 0,
				'autoplay': 1,
				'playsinline': 1,
				'enablejsapi': 1,
				'iv_load_policy': 3
			},
			events: {
				'onReady': onPlayerReady,
				'onStateChange': onPlayerStateChange
			}
		})
		}, 1000)
	}
	function onPlayerReady(event) { document.getElementById("player-loading").classList.add("hidden") }
	function onPlayerStateChange(event) {
		if (withProgress && (event.data == YT.PlayerState.ENDED || event.data == YT.PlayerState.PAUSED)) {
			saveProgress()
		}
	}
	let lastProgress = 0
	function saveProgress() {
		var currentTime = Math.floor(window.player.getCurrentTime())
		if (lastProgress === currentTime) return true
		lastProgress = currentTime

		fetch(`/api/videos/${video}/progress?progress=` + currentTime, {
			method: 'POST',
			credentials: 'include'
		})
		return true
	}
}

script sponsorBlockInit(segments []types.SegmentProps) {
	document.addEventListener("DOMContentLoaded", () => {
		console.log("sponsorBlockInit", segments)
		if (segments.length > 0) {
			setInterval(() => {
				if (window.player && window.player.getPlayerState && window.player.getPlayerState() === YT.PlayerState.PLAYING) {
					var currentTime = window.player.getCurrentTime()
					var segment = segments.find(segment => segment.start <= currentTime && segment.end >= currentTime)
					if (segment) {
						console.info("skipping segment")
						window.player.seekTo(segment.end, true)
					}
				}
			}, 1000)
		}
	})
}

